<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>Split Focus</title>
    <!-- Social Meta Tags -->
    <meta property="og:title" content="Split Focus - Dual Lane Survival" />
    <meta property="og:description"
        content="Test your reflexes! Control two players simultaneously and survive the falling neon blocks." />
    <meta property="og:image" content="https://placehold.co/1200x630/101020/ffcc55?text=Split+Focus" />
    <meta property="og:url" content="https://split-focus.game" />
    <meta name="twitter:card" content="summary_large_image" />

    <!-- Google Analytics 4 (Placeholder) -->
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-NTX74GN87P"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-NTX74GN87P');
    </script>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;600;800&display=swap" rel="stylesheet">


    <!-- Microsoft Clarity (Placeholder) -->
    <script type="text/javascript">
        (function (c, l, a, r, i, t, y) {
            c[a] = c[a] || function () { (c[a].q = c[a].q || []).push(arguments) };
            t = l.createElement(r); t.async = 1; t.src = "https://www.clarity.ms/tag/" + i;
            y = l.getElementsByTagName(r)[0]; y.parentNode.insertBefore(t, y);
        })(window, document, "clarity", "script", "v0fv4htbhm");
    </script>

    <style>
        :root {
            --vh: 1vh;
            --bg: #050509;
            --fg: #f5f5f5;
            --muted: rgba(245, 245, 245, 0.6);
            --border: rgba(255, 255, 255, 0.1);
            --accent: #ffcc55;
            --glass: rgba(255, 255, 255, 0.05);
        }

        html,
        body {
            margin: 0;
            padding: 0;
            background: var(--bg);
            color: var(--fg);
            font-family: 'Outfit', system-ui, -apple-system, sans-serif;
            overflow: hidden;
            height: 100%;
            -webkit-tap-highlight-color: transparent;
        }

        #gameContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            height: calc(var(--vh) * 100);
            padding: 10px;
            box-sizing: border-box;
            gap: 8px;
        }

        #ui {
            width: min(640px, 96vw);
            text-align: center;
            padding: 8px 10px;
            border: 1px solid var(--border);
            border-radius: 12px;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0.02));
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.35);
        }

        #ui h1 {
            margin: 6px 0 2px;
            font-size: 18px;
            letter-spacing: 0.8px;
        }

        #ui p {
            margin: 2px 0;
            font-size: 13px;
            color: var(--muted);
            line-height: 1.25;
        }

        #topRow {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            margin-top: 6px;
            flex-wrap: wrap;
        }

        #scoreRow {
            display: flex;
            justify-content: center;
            gap: 14px;
            font-size: 14px;
            padding: 4px 8px;
            border: 1px solid var(--border);
            border-radius: 999px;
            background: rgba(0, 0, 0, 0.18);
        }

        #btnRow {
            display: flex;
            gap: 8px;
            align-items: center;
            justify-content: center;
        }

        button {
            appearance: none;
            border: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.4);
            color: var(--fg);
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.15s ease;
            user-select: none;
            touch-action: manipulation;
            font-family: inherit;
        }

        button:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }

        button:active {
            transform: scale(0.96);
        }

        .btn-accent {
            background: rgba(255, 204, 85, 0.15);
            border-color: rgba(255, 204, 85, 0.4);
            color: #ffda80;
        }

        .btn-coffee {
            background: #FFDD00;
            color: #000;
            border: none;
            font-weight: 600;
        }

        /* Enhanced Game Over Screen */
        #gameOverOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 5, 9, 0.9);
            backdrop-filter: blur(12px);
            display: none;
            /* Toggled via JS */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #gameOverOverlay.visible {
            opacity: 1;
        }

        .stats-card {
            background: linear-gradient(145deg, rgba(30, 30, 45, 0.9), rgba(20, 20, 30, 0.95));
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-top: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 20px;
            padding: 28px;
            width: min(340px, 88%);
            text-align: center;
            box-shadow: 0 25px 60px rgba(0, 0, 0, 0.6), inset 0 1px 0 rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            gap: 18px;
            transform: translateY(10px);
            animation: slideUp 0.4s cubic-bezier(0.18, 0.89, 0.32, 1.28) forwards;
        }

        @keyframes slideUp {
            to {
                transform: translateY(0);
            }
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin: 4px 0;
        }

        .stat-item {
            background: rgba(0, 0, 0, 0.25);
            padding: 12px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.03);
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .stat-val {
            font-size: 24px;
            font-weight: 800;
            color: #fff;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .stat-label {
            font-size: 11px;
            color: var(--muted);
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
            margin-top: 2px;
        }

        .share-row {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
            margin-top: 6px;
        }

        .share-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 44px;
            border-radius: 10px;
            border: none;
            font-size: 20px;
            color: white;
            transition: transform 0.1s;
        }

        .btn-x {
            background: #000;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-wa {
            background: #25D366;
        }

        .btn-copy {
            background: rgba(255, 255, 255, 0.1);
        }

        .share-btn:active {
            transform: scale(0.94);
        }

        #shareMsg {
            grid-column: span 3;
            font-size: 11px;
            color: var(--muted);
            margin-top: -6px;
        }

        /* Footer */
        #footer {
            margin-top: 12px;
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        #message {
            margin-top: 6px;
            font-size: 14px;
            color: var(--accent);
            min-height: 18px;
        }

        .orientHint {
            margin: 8px auto 0;
            width: fit-content;
            max-width: 100%;
            padding: 8px 10px;
            border-radius: 10px;
            border: 1px solid rgba(255, 204, 85, 0.35);
            background: rgba(255, 204, 85, 0.10);
            color: rgba(255, 240, 210, 0.95);
            font-size: 12.5px;
            line-height: 1.25;
        }

        .orientHint b {
            color: rgba(255, 230, 170, 1);
        }

        #history {
            margin-top: 6px;
            font-size: 13px;
            color: var(--muted);
            display: flex;
            flex-direction: column;
            gap: 4px;
            align-items: center;
        }

        .hint {
            color: var(--muted);
            font-size: 12px;
        }

        #historyList {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 6px;
        }

        .chip {
            border: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.18);
            border-radius: 999px;
            padding: 4px 10px;
            font-size: 12px;
            color: rgba(245, 245, 245, 0.85);
        }

        #gameCanvas {
            width: min(640px, 96vw);
            height: min(78vh, 860px);
            border: 2px solid rgba(255, 255, 255, 0.18);
            border-radius: 14px;
            background: radial-gradient(circle at top, #181830 0, #050509 60%);
            box-shadow: 0 18px 40px rgba(0, 0, 0, 0.45);
            touch-action: none;
            display: block;
        }

        @media (max-width: 420px) {
            #ui h1 {
                font-size: 16px;
            }

            #scoreRow {
                font-size: 13px;
            }

            button {
                padding: 10px 12px;
            }
        }
    </style>
</head>

<body>
    <div id="gameContainer">
        <div id="ui">
            <h1>Split Focus</h1>
            <p>Controls: <b>A</b> for Left, <b>L</b> for Right ‚Ä¢ <b>P</b> to Pause ‚Ä¢ Or tap each half</p>

            <div id="orientHint" class="orientHint" style="display:none" role="status" aria-live="polite">
                Best experienced in <b>portrait</b>. Rotate your phone for a clearer view.
            </div>

            <div id="topRow">
                <div id="scoreRow">
                    <span>Score: <span id="score">0</span></span>
                    <span>Best: <span id="bestScore">0</span></span>
                </div>
                <div id="btnRow">
                    <button id="pauseBtn" aria-label="Pause">Pause</button>
                    <button id="restartBtn" aria-label="Restart">Restart</button>
                    <button id="muteBtn" aria-label="Mute Audio">üîä</button>
                </div>
            </div>

            <div id="message"></div>

            <!-- New Game Over Overlay -->
            <div id="gameOverOverlay">
                <div class="stats-card">
                    <h2
                        style="margin:0; font-size:28px; font-weight:800; background:linear-gradient(to right, #fff, #bbb); -webkit-background-clip:text; -webkit-text-fill-color:transparent;">
                        Game Over</h2>

                    <div class="stats-grid">
                        <div class="stat-item">
                            <div class="stat-val" id="finalScore" style="color:var(--accent);">0</div>
                            <div class="stat-label">Score</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-val" id="finalHigh">0</div>
                            <div class="stat-label">Best</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-val" id="statSwaps">0</div>
                            <div class="stat-label">Swaps</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-val" id="statDodged">0</div>
                            <div class="stat-label">Dodged</div>
                        </div>
                    </div>

                    <button id="reviveBtn" class="btn-accent"
                        style="display:none; width:100%; justify-content:center; font-weight:600; padding:12px;">
                        üì∫ Watch Ad to Revive
                    </button>

                    <div class="share-row">
                        <link rel="stylesheet"
                            href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
                        <button id="btnTwitter" class="share-btn btn-x" aria-label="Share on X">ùïè</button>
                        <button id="btnWhatsapp" class="share-btn btn-wa" aria-label="Share on WhatsApp">üí¨</button>
                        <button id="btnCopy" class="share-btn btn-copy" aria-label="Copy Link">üìã</button>
                    </div>
                    <div id="shareMsg">Share your score</div>

                    <button id="restartOverlayBtn" style="padding:12px; font-weight:600; font-family:inherit;">
                        ‚Ü∫ Play Again
                    </button>
                </div>
            </div>

            <div id="footer">
                <!-- 
                    Link updated to user's profile.
                -->
                <a href="https://buymeacoffee.com/bongquisitive" target="_blank" class="btn-coffee"
                    style="text-decoration:none; padding:8px 12px; border-radius:8px; font-size:12px;">‚òï Buy me a
                    Coffee</a>
            </div>

            <div id="history">
                <div class="hint">Last 5 tries</div>
                <div id="historyList"></div>
            </div>
        </div>

        <canvas id="gameCanvas"></canvas>
    </div>

    <script>
        (function () {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');

            const scoreEl = document.getElementById('score');
            const bestScoreEl = document.getElementById('bestScore');
            const messageEl = document.getElementById('message');
            const historyListEl = document.getElementById('historyList');
            const pauseBtn = document.getElementById('pauseBtn');
            const restartBtn = document.getElementById('restartBtn');
            const orientHintEl = document.getElementById('orientHint');

            // NEW UI References
            const muteBtn = document.getElementById('muteBtn');
            const gameOverOverlay = document.getElementById('gameOverOverlay');
            const finalScoreEl = document.getElementById('finalScore');
            const finalHighEl = document.getElementById('finalHigh');
            const statSwapsEl = document.getElementById('statSwaps');
            const statDodgedEl = document.getElementById('statDodged');
            const reviveBtn = document.getElementById('reviveBtn');
            const restartOverlayBtn = document.getElementById('restartOverlayBtn');

            // --- AUDIO SYSTEM (Synthesized) ---
            const Sound = {
                ctx: null,
                muted: false,
                init: function () {
                    if (!window.AudioContext) return;
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                },
                play: function (type) {
                    if (this.muted || !this.ctx) return;
                    if (this.ctx.state === 'suspended') this.ctx.resume();

                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.connect(gain);
                    gain.connect(this.ctx.destination);

                    const now = this.ctx.currentTime;

                    if (type === 'tap') {
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(600, now);
                        osc.frequency.exponentialRampToValueAtTime(300, now + 0.1);
                        gain.gain.setValueAtTime(0.1, now);
                        gain.gain.linearRampToValueAtTime(0, now + 0.1);
                        osc.start(now);
                        osc.stop(now + 0.1);
                    } else if (type === 'crash') {
                        osc.type = 'sawtooth';
                        osc.frequency.setValueAtTime(100, now);
                        osc.frequency.exponentialRampToValueAtTime(20, now + 0.3);
                        gain.gain.setValueAtTime(0.2, now);
                        gain.gain.linearRampToValueAtTime(0, now + 0.3);
                        osc.start(now);
                        osc.stop(now + 0.3);
                    } else if (type === 'score') {
                        osc.type = 'triangle';
                        osc.frequency.setValueAtTime(800, now);
                        gain.gain.setValueAtTime(0.05, now);
                        gain.gain.linearRampToValueAtTime(0, now + 0.1);
                        osc.start(now);
                        osc.stop(now + 0.1);
                    } else if (type === 'revive') {
                        osc.type = 'square';
                        osc.frequency.setValueAtTime(200, now);
                        osc.frequency.linearRampToValueAtTime(600, now + 0.4);
                        gain.gain.setValueAtTime(0.1, now);
                        gain.gain.linearRampToValueAtTime(0, now + 0.4);
                        osc.start(now);
                        osc.stop(now + 0.4);
                    }
                },
                toggle: function () {
                    this.muted = !this.muted;
                    muteBtn.textContent = this.muted ? 'üîá' : 'üîä';
                }
            };

            muteBtn.addEventListener('click', (e) => {
                e.target.blur(); // remove focus
                Sound.init(); // lazy init
                Sound.toggle();
            });


            // Persisted data
            const BEST_KEY = 'splitFocusBestScore';
            const HIST_KEY = 'splitFocusLast5';

            let bestScore = parseFloat(localStorage.getItem(BEST_KEY) || '0');
            bestScoreEl.textContent = Math.floor(bestScore);

            function loadHistory() {
                try {
                    const raw = localStorage.getItem(HIST_KEY);
                    const arr = raw ? JSON.parse(raw) : [];
                    return Array.isArray(arr) ? arr : [];
                } catch {
                    return [];
                }
            }

            function saveHistory(arr) {
                localStorage.setItem(HIST_KEY, JSON.stringify(arr.slice(0, 5)));
            }

            function renderHistory() {
                const hist = loadHistory();
                historyListEl.innerHTML = '';
                if (hist.length === 0) {
                    const chip = document.createElement('span');
                    chip.className = 'chip';
                    chip.textContent = '‚Äî';
                    historyListEl.appendChild(chip);
                    return;
                }
                hist.forEach(s => {
                    const chip = document.createElement('span');
                    chip.className = 'chip';
                    chip.textContent = String(s);
                    historyListEl.appendChild(chip);
                });
            }

            function recordScore(s) {
                const hist = loadHistory();
                hist.unshift(s);
                saveHistory(hist);
                renderHistory();
            }

            renderHistory();

            // --- Mobile viewport robustness (address-bar / dynamic viewport height) ---
            function viewportSize() {
                const w = (window.visualViewport && window.visualViewport.width) ? window.visualViewport.width : window.innerWidth;
                const h = (window.visualViewport && window.visualViewport.height) ? window.visualViewport.height : window.innerHeight;
                return { w, h };
            }

            function setVhVar() {
                const { h } = viewportSize();
                document.documentElement.style.setProperty('--vh', `${h * 0.01}px`);
            }

            function updateOrientationHint() {
                const { w, h } = viewportSize();
                const isLandscape = w > h;
                const cramped = h < 520;
                orientHintEl.style.display = (isLandscape && cramped) ? 'block' : 'none';
            }

            // --- Responsive, crisp canvas (avoid ResizeObserver loop) ---
            let W = 500;
            let H = 700;
            let laneWidth = W / 4;

            let resizeScheduled = false;
            let lastCssW = 0;
            let lastCssH = 0;

            function resizeCanvasNow() {
                resizeScheduled = false;

                // Use bounding rect to reduce feedback loops vs clientWidth/clientHeight
                const rect = canvas.getBoundingClientRect();
                const cssW = Math.max(1, Math.floor(rect.width));
                const cssH = Math.max(1, Math.floor(rect.height));

                // Bail if nothing actually changed
                if (cssW === lastCssW && cssH === lastCssH) return;
                lastCssW = cssW;
                lastCssH = cssH;

                const dpr = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));
                const targetW = Math.floor(cssW * dpr);
                const targetH = Math.floor(cssH * dpr);

                // Only set when needed (setting width/height can trigger layout)
                if (canvas.width !== targetW) canvas.width = targetW;
                if (canvas.height !== targetH) canvas.height = targetH;

                // Render in CSS pixel space
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                W = cssW;
                H = cssH;
                laneWidth = W / 4;
            }

            function scheduleResize() {
                if (resizeScheduled) return;
                resizeScheduled = true;
                requestAnimationFrame(() => {
                    setVhVar();
                    updateOrientationHint();
                    resizeCanvasNow();
                });
            }

            // Prefer ResizeObserver if available, but schedule resize via rAF to avoid loop warnings.
            let ro = null;
            if (window.ResizeObserver) {
                ro = new ResizeObserver(() => scheduleResize());
                // Observe parent container instead of canvas to avoid canvas size mutations feeding back.
                ro.observe(document.getElementById('gameContainer'));
            }

            window.addEventListener('resize', scheduleResize);
            window.addEventListener('orientationchange', scheduleResize);
            if (window.visualViewport) {
                window.visualViewport.addEventListener('resize', scheduleResize);
                window.visualViewport.addEventListener('scroll', scheduleResize);
            }

            // Initial sizing
            scheduleResize();

            // Game state
            let leftLaneIndex = 0;
            let rightLaneIndex = 0;

            let obstacles = [];
            let lastSpawnTime = 0;
            let spawnInterval = 900;
            let baseSpeed = 2.2;
            let speedMultiplier = 1;
            let running = false;
            let paused = false;
            let gameOver = false;
            let lastTime = 0;
            let score = 0;

            // New Stats
            let totalSwaps = 0;
            let obstaclesDodged = 0;
            let revivedUsed = false;
            let invulnerableUntil = 0; // timestamp

            // Visuals
            let shakeTime = 0;
            let particles = [];


            function playerRect(isLeftSide) {
                const playerY = H - Math.max(56, H * 0.08);
                const pw = laneWidth * 0.72;
                const ph = Math.max(18, H * 0.026);
                const laneIndex = isLeftSide ? leftLaneIndex : rightLaneIndex;
                return {
                    x: getLaneX(isLeftSide, laneIndex) + laneWidth * 0.02,
                    y: playerY,
                    width: pw,
                    height: ph
                };
            }

            function resetGame() {
                obstacles = [];
                leftLaneIndex = 0;
                rightLaneIndex = 0;
                spawnInterval = 900;
                baseSpeed = 2.2;
                speedMultiplier = 1;
                score = 0;
                totalSwaps = 0;
                obstaclesDodged = 0;
                revivedUsed = false;
                invulnerableUntil = 0;
                particles = [];
                shakeTime = 0;

                scoreEl.textContent = '0';
                gameOver = false;
                paused = false;
                running = true;
                pauseBtn.textContent = 'Pause';

                // Hide Overlay
                gameOverOverlay.classList.remove('visible');
                gameOverOverlay.style.display = 'none';

                messageEl.textContent = '';
                lastTime = performance.now();
                lastSpawnTime = lastTime;

                // Ensure audio init
                Sound.init();

            }

            function startIfNotRunning() {
                if (!running) resetGame();
            }

            function togglePause() {
                if (!running) return;
                paused = !paused;
                pauseBtn.textContent = paused ? 'Resume' : 'Pause';
                messageEl.textContent = paused ? 'Paused' : '';
                lastTime = performance.now();
            }

            function getLaneX(isLeftSide, laneIndex) {
                const globalLaneIndex = isLeftSide ? laneIndex : laneIndex + 2;
                return globalLaneIndex * laneWidth + laneWidth * 0.15;
            }

            function spawnObstacle(now) {
                const pr = playerRect(true);
                const obW = pr.width;
                const obH = pr.height;

                function pickLaneSafe(isLeftSide, proposedLane) {
                    const newY = -obH - 10;
                    const otherLane = 1 - proposedLane;

                    let minOtherY = Infinity;
                    for (const ob of obstacles) {
                        if (ob.isLeftSide === isLeftSide && ob.laneIndex === otherLane) {
                            if (ob.y < minOtherY) minOtherY = ob.y;
                        }
                    }

                    const safeGap = Math.max(14, obH * 0.8);
                    const minAllowedOtherY = newY + obH + safeGap;
                    if (minOtherY < minAllowedOtherY) return otherLane;
                    return proposedLane;
                }

                [true, false].forEach(isLeftSide => {
                    let laneIndex = Math.random() < 0.5 ? 0 : 1;
                    laneIndex = pickLaneSafe(isLeftSide, laneIndex);
                    obstacles.push({
                        isLeftSide,
                        laneIndex,
                        x: getLaneX(isLeftSide, laneIndex) + laneWidth * 0.02,
                        y: -obH - 10,
                        width: obW,
                        height: obH,
                    });
                });

                lastSpawnTime = now;
            }

            function rectsOverlap(a, b) {
                return !(a.x + a.width < b.x || a.x > b.x + b.width || a.y + a.height < b.y || a.y > b.y + b.height);
            }

            function update(dt, now) {
                if (!running || paused) return;

                const timeSeconds = score / 100;
                speedMultiplier = 1 + timeSeconds * 0.12;
                spawnInterval = Math.max(250, 900 - timeSeconds * 50);
                const speed = baseSpeed * speedMultiplier;

                score += dt * 0.1 * speedMultiplier;
                scoreEl.textContent = Math.floor(score);

                // Audio Score Ping
                if (Math.floor(score) > 0 && Math.floor(score) % 100 === 0 && Math.floor(score) !== Math.floor(score - dt * 0.1 * speedMultiplier)) {
                    Sound.play('score');
                }

                if (now - lastSpawnTime > spawnInterval) spawnObstacle(now);

                const leftPlayer = playerRect(true);
                const rightPlayer = playerRect(false);

                // Shake Decay
                if (shakeTime > 0) shakeTime -= dt;

                // Update Particles
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.x += p.vx * dt * 0.06;
                    p.y += p.vy * dt * 0.06;
                    p.life -= dt;
                    if (p.life <= 0) particles.splice(i, 1);
                }

                for (let i = obstacles.length - 1; i >= 0; i--) {
                    const ob = obstacles[i];
                    ob.y += speed * dt * 0.06;

                    // Invulnerability check
                    const isInvulnerable = now < invulnerableUntil;

                    if (!isInvulnerable) {
                        if (ob.isLeftSide) {
                            if (rectsOverlap(ob, leftPlayer)) {
                                createExplosion(leftPlayer.x + leftPlayer.width / 2, leftPlayer.y + leftPlayer.height / 2, '#55ddff');
                                endGame(); return;
                            }
                        } else {
                            if (rectsOverlap(ob, rightPlayer)) {
                                createExplosion(rightPlayer.x + rightPlayer.width / 2, rightPlayer.y + rightPlayer.height / 2, '#ff6688');
                                endGame(); return;
                            }
                        }
                    }

                    if (ob.y > H + 80) {
                        obstacles.splice(i, 1);
                        obstaclesDodged++;
                    }
                }
            }

            function endGame() {
                running = false;
                gameOver = true;
                paused = false;
                pauseBtn.textContent = 'Pause';

                Sound.play('crash');
                shakeTime = 500; // 500ms shake

                const finalScore = Math.floor(score);
                recordScore(finalScore);

                if (finalScore > Math.floor(bestScore)) {
                    bestScore = finalScore;
                    localStorage.setItem(BEST_KEY, String(bestScore));
                    bestScoreEl.textContent = String(bestScore);
                }

                // Show Overlay
                finalScoreEl.textContent = finalScore;
                finalHighEl.textContent = Math.floor(bestScore);
                statSwapsEl.textContent = totalSwaps;
                statDodgedEl.textContent = obstaclesDodged;

                reviveBtn.style.display = revivedUsed ? 'none' : 'flex';

                gameOverOverlay.style.display = 'flex';
                // Trigger reflow
                void gameOverOverlay.offsetWidth;
                gameOverOverlay.classList.add('visible');
            }

            // Drawing
            function roundRect(x, y, w, h, r) {
                const rr = Math.min(r, w / 2, h / 2);
                ctx.beginPath();
                ctx.moveTo(x + rr, y);
                ctx.arcTo(x + w, y, x + w, y + h, rr);
                ctx.arcTo(x + w, y + h, x, y + h, rr);
                ctx.arcTo(x, y + h, x, y, rr);
                ctx.arcTo(x, y, x + w, y, rr);
                ctx.closePath();
            }

            function drawPlayer(x, y, w, h, color) {
                const r = Math.min(10, h * 0.35);
                ctx.fillStyle = color;
                roundRect(x, y, w, h, r);
                ctx.fill();

                ctx.fillStyle = 'rgba(255,255,255,0.12)';
                roundRect(x + w * 0.06, y + h * 0.18, w * 0.55, h * 0.18, r);
                ctx.fill();
            }

            function drawObstacle(x, y, w, h, color) {
                const r = Math.min(10, h * 0.35);
                ctx.fillStyle = color;
                roundRect(x, y, w, h, r);
                ctx.fill();

                ctx.fillStyle = 'rgba(0,0,0,0.18)';
                roundRect(x + w * 0.12, y + h * 0.22, w * 0.18, h * 0.56, r);
                ctx.fill();
            }

            function render() {
                ctx.setTransform(1, 0, 0, 1, 0, 0); // reset for clear
                ctx.clearRect(0, 0, W, H);

                // Shake Transform
                let shakeX = 0;
                let shakeY = 0;
                if (shakeTime > 0) {
                    const mag = (shakeTime / 500) * 10;
                    shakeX = (Math.random() - 0.5) * mag;
                    shakeY = (Math.random() - 0.5) * mag;
                }

                // Re-apply scale for standard drawing
                const dpr = window.devicePixelRatio || 1;
                // We need to fetch current scale; previously handled in resize.
                // Simplified: Just use the stored scale if we can, 
                // but simpler is to just apply shake in the draw calls or wrap logic.
                // Let's use save/restore.

                // Actually, resizeCanvasNow sets transform. We should rely on that or reset it.
                // Since resizeCanvasNow is called on resize, the context already has a transform.
                // Let's just modify the current transform? No, simplest is to save/restore.

                // Wait, clearRect ignores transform? No.
                // Let's assume standard flow:

                // 1. Clear (using full canvas dims)
                ctx.save();
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.restore();

                ctx.save();
                // Apply Shake
                ctx.translate(shakeX, shakeY);

                ctx.fillStyle = '#101020';
                ctx.fillRect(0, 0, W / 2, H);
                ctx.fillStyle = '#141424';
                ctx.fillRect(W / 2, 0, W / 2, H);

                ctx.strokeStyle = 'rgba(255,255,255,0.05)';
                ctx.lineWidth = 2;
                for (let i = 1; i < 4; i++) {
                    const x = i * laneWidth;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, H);
                    ctx.stroke();
                }

                ctx.fillStyle = 'rgba(255,255,255,0.06)';
                ctx.fillRect(W / 2 - 2, 0, 4, H);

                // Draw Particles
                particles.forEach(p => {
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.life / 600;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                });

                // Blink if invulnerable
                if (performance.now() < invulnerableUntil && Math.floor(performance.now() / 100) % 2 === 0) {
                    // skip drawing players
                } else {
                    const lp = playerRect(true);
                    const rp = playerRect(false);
                    drawPlayer(lp.x, lp.y, lp.width, lp.height, '#55ddff');
                    drawPlayer(rp.x, rp.y, rp.width, rp.height, '#ff6688');
                }

                obstacles.forEach(ob => {
                    const c = ob.isLeftSide ? 'rgba(120,220,255,0.85)' : 'rgba(255,160,190,0.88)';
                    drawObstacle(ob.x, ob.y, ob.width, ob.height, c);
                });

                ctx.restore(); // End Shake

                if (paused) {
                    ctx.fillStyle = 'rgba(0,0,0,0.35)';
                    ctx.fillRect(0, 0, W, H);
                    ctx.fillStyle = 'rgba(255,255,255,0.92)';
                    ctx.font = 'bold 28px system-ui, -apple-system, Segoe UI, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('Paused', W / 2, H / 2);
                    ctx.font = '14px system-ui, -apple-system, Segoe UI, sans-serif';
                    ctx.fillStyle = 'rgba(255,255,255,0.7)';
                    ctx.fillText('Press P or tap Pause to continue', W / 2, H / 2 + 34);
                }

                if (!running && !gameOver) {
                    ctx.fillStyle = 'rgba(0,0,0,0.18)';
                    ctx.fillRect(0, 0, W, H);
                    ctx.fillStyle = 'rgba(255,255,255,0.92)';
                    ctx.font = 'bold 22px system-ui, -apple-system, Segoe UI, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('Tap left/right to start', W / 2, H / 2);
                    ctx.font = '14px system-ui, -apple-system, Segoe UI, sans-serif';
                    ctx.fillStyle = 'rgba(255,255,255,0.7)';
                    ctx.fillText('A toggles left ‚Ä¢ L toggles right ‚Ä¢ P pauses', W / 2, H / 2 + 30);
                }
            }

            function loop(now) {
                requestAnimationFrame(loop);
                const dt = (now - lastTime) || 16;
                lastTime = now;
                update(dt, now);
                render();
            }

            // Input
            function toggleLeft() {
                leftLaneIndex = 1 - leftLaneIndex;
                Sound.play('tap');
                if (running && !gameOver) totalSwaps++;
            }
            function toggleRight() {
                rightLaneIndex = 1 - rightLaneIndex;
                Sound.play('tap');
                if (running && !gameOver) totalSwaps++;
            }

            window.addEventListener('keydown', (e) => {
                if (e.repeat) return;

                if (e.key === 'p' || e.key === 'P') {
                    togglePause();
                    return;
                }

                if (e.key === 'a' || e.key === 'A') {
                    if (!running) startIfNotRunning();
                    else if (!paused) toggleLeft();
                    return;
                }

                if (e.key === 'l' || e.key === 'L') {
                    if (!running) startIfNotRunning();
                    else if (!paused) toggleRight();
                    return;
                }
            });

            pauseBtn.addEventListener('click', () => {
                if (!running) return;
                togglePause();
            });

            restartBtn.addEventListener('click', () => {
                resetGame();
            });

            function getCanvasXFromEvent(clientX) {
                const rect = canvas.getBoundingClientRect();
                const x = clientX - rect.left;
                const scaleX = W / rect.width;
                return x * scaleX;
            }

            function handlePointerAtClientX(clientX) {
                if (!running) { startIfNotRunning(); return; }
                if (paused) return;

                const x = getCanvasXFromEvent(clientX);
                if (x < W / 2) toggleLeft();
                else toggleRight();
            }

            canvas.addEventListener('mousedown', (e) => {
                handlePointerAtClientX(e.clientX);
            });

            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                for (let i = 0; i < e.changedTouches.length; i++) {
                    handlePointerAtClientX(e.changedTouches[i].clientX);
                }
            }, { passive: false });

            // Initial UI message
            messageEl.textContent = 'Tap or press A/L to start.';

            // --- Self-tests (lightweight) ---
            // Ensures we don't create two-lane walls near the spawn band.
            // Runs once; logs only on failure.
            function runSelfTests() {
                try {
                    // Fake a tiny environment
                    W = 500; H = 700; laneWidth = W / 4;
                    obstacles = [];
                    leftLaneIndex = 0; rightLaneIndex = 0;

                    // Force repeated spawns; check that on each side, you never have both lanes occupied with too-small vertical gap near the top.
                    const iterations = 200;
                    const pr = playerRect(true);
                    const obH = pr.height;
                    const safeGap = Math.max(14, obH * 0.8);
                    const newY = -obH - 10;
                    const minAllowedOtherY = newY + obH + safeGap;

                    for (let i = 0; i < iterations; i++) {
                        spawnObstacle(performance.now());
                        for (const side of [true, false]) {
                            const lane0 = obstacles.filter(o => o.isLeftSide === side && o.laneIndex === 0).map(o => o.y);
                            const lane1 = obstacles.filter(o => o.isLeftSide === side && o.laneIndex === 1).map(o => o.y);
                            const min0 = lane0.length ? Math.min(...lane0) : Infinity;
                            const min1 = lane1.length ? Math.min(...lane1) : Infinity;
                            // If both lanes have an obstacle very near top, ensure at least one isn't too close (otherwise it's a wall).
                            if (min0 < minAllowedOtherY && min1 < minAllowedOtherY) {
                                throw new Error('Self-test failed: potential two-lane wall detected.');
                            }
                        }
                    }
                } catch (err) {
                    console.error(err);
                }
            }

            runSelfTests();

            // --- Helper Functions ---

            function createExplosion(x, y, color) {
                for (let i = 0; i < 12; i++) {
                    particles.push({
                        x, y,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 0.5) * 8,
                        life: 600 + Math.random() * 200,
                        color: color,
                        size: 2 + Math.random() * 3
                    });
                }
            }

            function reviveGame() {
                if (revivedUsed) return;
                revivedUsed = true;

                // Clear near obstacles
                const playerY = H - Math.max(56, H * 0.08);
                obstacles = obstacles.filter(ob => ob.y < playerY - 300); // clear bottom 300px

                running = true;
                gameOver = false;
                invulnerableUntil = performance.now() + 2000;
                lastTime = performance.now();
                lastSpawnTime = lastTime; // Reset spawn timer to avoid instant flood

                gameOverOverlay.classList.remove('visible');
                setTimeout(() => gameOverOverlay.style.display = 'none', 300);

                Sound.play('revive');
            }

            restartOverlayBtn.addEventListener('click', () => {
                resetGame();
            });

            reviveBtn.addEventListener('click', () => {
                // Simulate Ad
                const originalText = reviveBtn.innerHTML;
                reviveBtn.disabled = true;
                reviveBtn.textContent = 'Loading Ad...';

                setTimeout(() => {
                    reviveBtn.textContent = 'Ad Playing (3s)...';
                    // In a real game, show video SDK here
                    setTimeout(() => {
                        reviveGame();
                        reviveBtn.textContent = originalText;
                        reviveBtn.disabled = false;
                    }, 2500);
                }, 800);
            });

            const btnTwitter = document.getElementById('btnTwitter');
            const btnWhatsapp = document.getElementById('btnWhatsapp');
            const btnCopy = document.getElementById('btnCopy');
            const shareMsgEl = document.getElementById('shareMsg');

            function getShareText() {
                // Cool share messages to encourage others
                const msgs = [
                    `My brain just split in two! Scored ${Math.floor(score)} in Split Focus! ü§Ø`,
                    `Reflex check: Failed after ${Math.floor(score)} points. üò≠ Can you beat me?`,
                    `I scored ${Math.floor(score)} in a dual-lane panic attack. ‚ö°`,
                    `Dual lanes, one brain, ${Math.floor(score)} points. #SplitFocus`
                ];
                return msgs[Math.floor(Math.random() * msgs.length)];
            }

            if (btnTwitter) btnTwitter.addEventListener('click', () => {
                const text = getShareText();
                const url = encodeURIComponent(window.location.href);
                const fullText = encodeURIComponent(text + " Play here: ");
                window.open(`https://twitter.com/intent/tweet?text=${fullText}&url=${url}&hashtags=SplitFocus,IndieGame`, '_blank');
            });

            if (btnWhatsapp) btnWhatsapp.addEventListener('click', () => {
                const text = getShareText();
                const url = window.location.href;
                const fullText = encodeURIComponent(`*Split Focus Challenge!* üéÆ\n\n${text}\n\nPlay here: ${url}`);
                window.open(`https://wa.me/?text=${fullText}`, '_blank');
            });

            if (btnCopy) btnCopy.addEventListener('click', () => {
                const text = `${getShareText()} Play here: ${window.location.href}`;
                navigator.clipboard.writeText(text).then(() => {
                    shareMsgEl.textContent = '‚úÖ Copied to clipboard!';
                    setTimeout(() => shareMsgEl.textContent = 'Share your score', 2000);
                }).catch(() => {
                    shareMsgEl.textContent = '‚ùå Copy failed';
                });
            });

            // Start loop
            requestAnimationFrame((t) => {
                lastTime = t;
                lastSpawnTime = t;
                requestAnimationFrame(loop);
            });
        })();
    </script>
</body>

</html>